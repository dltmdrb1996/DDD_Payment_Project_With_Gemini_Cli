# Gemini CLI 개발 가이드라인

이 문서는 Gemini CLI를 사용하여 이 프로젝트의 코드를 생성하고 수정할 때 따라야 할 규칙과 가이드라인을 정의합니다.

# 1 설계 및 구현 원칙

- **DDD 최우선 (DDD First)**: 모든 구현은 도메인 주도 설계(DDD) 원칙을 최우선으로 고려합니다. (**#4 DDD 코드 스타일 세부 원칙** 참조)
- **클린 아키텍처 (Clean Architecture)**: 도메인 계층을 시스템의 심장부로 하는 클린 아키텍처를 적용합니다. 의존성 규칙은 항상 안쪽 계층(도메인)을 향해야 합니다.
- **SOLID 원칙 준수**: 유연하고 유지보수 가능한 코드 작성을 위해 SOLID 원칙을 준수합니다.
    - **의존관계 역전 원칙 (DIP) 적용**:
        - **`application` 계층은 `domain` 계층의 추상화(인터페이스)에 의존합니다.**
        - **`infrastructure` 계층은 `domain` 계층의 추상화(인터페이스)를 구현합니다.**
        - 이를 통해 도메인은 인프라 기술로부터 완벽하게 독립됩니다.
- **테스트 주도 개발 (TDD)**: 핵심 비즈니스 로직(도메인 모델, 도메인 행위) 구현 시 반드시 테스트 코드를 먼저 작성하고 이를 통과하는 코드를 구현합니다. (**#8 테스트 심층 원칙** 참조)
- **유비쿼터스 랭귀지 (Ubiquitous Language)**: 도메인 전문가와 합의된 공통 언어를 코드(클래스, 변수, 메서드명), 주석, 커밋 메시지 등 모든 산출물에 일관되게 적용하여 소통의 명확성을 극대화합니다.

# 2 코드 품질 원칙

- **단순성 (Simplicity - KISS Principle)**: 언제나 복잡한 솔루션보다 가장 단순하고 명료한 솔루션을 우선시합니다. 불필요한 복잡성을 추가하지 않습니다.
- **중복 방지 (Don't Repeat Yourself - DRY Principle)**: 코드 중복을 최대한 피하고, 로직을 적절히 추상화하여 재사용성을 높입니다.
- **불변성 지향 (Immutability by Default)**:
    - **`val` 사용을 기본으로 하며, 변경 가능한 상태(`var`)는 반드시 필요한 경우에만 최소한으로 사용합니다.**
    - 값 객체(Value Object)는 반드시 불변(Immutable)으로 설계하며, 엔티티(Entity)의 상태 변경도 명시적인 메서드를 통해서만 이루어져야 합니다.
- **명시적인 것이 암묵적인 것보다 낫다 (Explicit is better than implicit)**: 코드의 동작이 숨겨진 규칙이나 관례에 의존하기보다, 명시적으로 드러나도록 작성합니다.
- **효율성 (Efficiency)**: 코드의 명확성을 희생하지 않는 선에서, 리소스(예: CPU, 메모리, API 호출 횟수, LLM 토큰 사용량 등) 사용을 최소화하도록 출력을 최적화합니다.
- **가드레일 (Guardrails)**: 테스트 환경 외에는 개발이나 프로덕션 환경에서 모의(Mock) 데이터를 사용하지 않습니다. 실제와 유사한 환경에서 검증합니다.

# 3. 형상 관리(Git) 및 협업 규칙

안정적인 코드 통합과 원활한 팀 협업을 위해 아래의 형상 관리 및 협업 규칙을 반드시 준수합니다.

### 3-1. 브랜치 전략 (Git Flow 기반)

- **`main`**: **배포 가능한 안정 버전**의 코드만 존재하는 브랜치입니다. 오직 `develop` 또는 `hotfix` 브랜치에서만 병합됩니다.
- **`develop`**: **다음 배포 버전을 개발하는 통합 브랜치**입니다. 모든 기능 개발이 이곳으로 병합됩니다.
- **`feature/{기능-요약}`**: 새로운 기능 개발 및 버그 수정을 위한 브랜치입니다. `develop`에서 생성하며, `feature/login-api`와 같이 명명합니다.

### 3-2. 작업 흐름 (Workflow)

1.  **브랜치 생성**: 모든 작업은 로컬 `develop` 브랜치를 최신 상태로 업데이트한 후, `feature` 브랜치를 생성하며 시작합니다.
    ```bash
    git checkout develop
    git pull origin develop
    git checkout -b feature/{기능-요약}
    ```
2.  **개발 및 테스트**: 기능을 구현하고, 관련된 **단위/통합 테스트를 포함한 모든 테스트를 성공적으로 완료**하여 코드의 안정성을 보장합니다.
3.  **사전 공유 및 동기화**: **Pull Request(PR)를 생성하기 전,** 작업 내용에 대해 관련 팀원에게 구두 또는 메신저로 먼저 공유하여 변경 사항을 동기화하고 잠재적 충돌을 예방합니다.
4.  **Pull Request 생성**: 모든 테스트와 사전 공유가 완료되면, `develop` 브랜치를 대상으로 PR을 생성합니다.

### 3-3. 커밋 메시지 규칙 (Conventional Commits)

프로젝트의 변경 이력을 명확하게 파악하고, 버전 관리 및 변경 사항 추적을 용이하게 하기 위해 모든 커밋 메시지는 Conventional Commits 규칙을 따릅니다.

- **기본 구조**: `<type>: <subject>` 형식을 반드시 준수합니다. (예: `feat: 로그인 API 구현`)
- **커밋 타입(Type) 종류 및 설명**:

| Type       | 설명                                                                                                                              |
| :--------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **`feat`** | **새로운 기능 추가**: 사용자를 위한 새로운 기능이 추가되었을 때 사용합니다.                                                         |
| **`fix`**  | **버그 수정**: 코드의 버그를 수정했을 때 사용합니다.                                                                                |
| **`docs`** | **문서 수정**: README.md, API 명세 등 프로젝트의 문서를 수정했을 때 사용합니다. 코드 수정은 포함되지 않습니다.                       |
| **`style`**| **코드 스타일 수정**: 코드 포맷팅, 세미콜론 추가/삭제 등 기능적 변경 없이 코드 스타일만 수정했을 때 사용합니다.                      |
| **`refactor`**| **코드 리팩토링**: 버그 수정이나 기능 추가가 아닌, 코드 구조를 개선하는 리팩토링을 했을 때 사용합니다. (예: 성능 개선, 가독성 향상) |
| **`test`** | **테스트 관련**: 테스트 코드를 추가하거나 수정했을 때 사용합니다.                                                                   |
| **`chore`**| **기타 작업**: 빌드 설정, 패키지 매니저 구성 등 소스코드나 테스트와 직접 관련 없는 기타 자잘한 작업을 의미합니다.                   |

### 3-4. 브랜치 보호 규칙 (Branch Protection Rule)

- **직접 Push 금지**: `main`과 `develop` 브랜치에는 직접적인 코드 Push를 절대 금지합니다.
- **PR을 통한 병합**: 모든 코드 변경은 반드시 Pull Request(PR)를 통한 코드 리뷰 및 승인 절차를 거쳐야만 병합될 수 있습니다. (GitHub의 Branch Protection Rule 기능으로 강제)

# 4 DDD (Domain-Driven Design) 코드 스타일 세부 원칙

1.  **핵심 철학: 안전한 도메인 모델 (Safe Domain Model)**
    - **포카요케(Poka-yoke) 원칙**: 도메인 규칙에 위배되는 상태는 **인스턴스화 자체가 불가능하도록** 타입을 설계합니다. 모든 비즈니스 규칙과 제약 조건은 타입시스템을 통해 **컴파일 시점에 검증**하는 것을 최우선 목표로 합니다.

2.  **계층형 아키텍처 및 책임 분리**
    - **`interfaces` (표현/어댑터 계층)**:
        - **역할**: 외부 세계(Client, Web)와의 상호작용. REST Controller, DTO 정의.
        - **책임**:
            - 외부의 **불안전한 데이터**(JSON, Form data 등)를 받는 DTO(Data Transfer Object)를 정의합니다. DTO는 유효성 검증 어노테이션을 포함할 수 있습니다.
            - 컨트롤러는 DTO를 애플리케이션 계층의 **유스케이스 `Request` 객체로 변환**하고, 해당 유스케이스를 실행시키는 역할만 수행합니다.
            - 애플리케이션 서비스에서 반환된 **`Response` 객체를 HTTP 응답(JSON 등)으로 변환**하여 클라이언트에 전달합니다.
    - **`application` (애플리케이션 계층 - UseCase)**:
        - **역할**: **유스케이스(Use Case)의 캡슐화 및 구현.**
        - **네이밍 및 구조**:
            - **각 유스케이스는 단일 public 메서드(`invoke` 또는 `execute`)를 가진 하나의 클래스**로 구현하며, 행위를 나타내는 명사형(`Register`, `ProcessPayment` 등)으로 명명합니다.
            - **입력(Request)과 출력(Response) 데이터는 해당 유스케이스 클래스 내부에 중첩 `data class`로 캡슐화**하여 유스케이스의 입출력을 명확히 합니다.
        - **책임**:
            - 비즈니스 흐름을 **조정(Orchestrate)** 합니다.
            - **`domain` 계층에 정의된 리포지토리 인터페이스를 주입받아, 애그리게잇을 조회하고 저장하는 영속성 흐름을 관리합니다.**
            - 조회된 도메인 객체의 메서드를 호출하여 상태 변경을 위임합니다.
            - 트랜잭션 경계, 보안 검증 등 기술적, 응용적 서비스를 처리합니다.
    - **`domain` (도메인 계층 - 시스템의 심장)**:
        - **역할**: 순수한 비즈니스 규칙과 정책의 표현. **Spring 프레임워크를 포함한 다른 어떤 계층에도 의존하지 않습니다.**
        - **구성 요소**:
            - **애그리게잇, 엔티티, 값 객체**: 핵심 비즈니스 모델.
            - **리포지토리 인터페이스(Port)**: 영속성 메커니즘을 추상화한 **명세(Contract)를 정의**합니다.
            - **역할 기반 서비스**: 특정 애그리게잇에 속하지 않는 순수 도메인 로직. **`~Service` 대신 `~Validator`, `~Creator`, `~Policy` 등 구체적인 역할을 나타내는 이름**을 사용합니다. **리포지토리에 직접 의존하지 않으며**, 필요한 모든 데이터는 파라미터로 전달받습니다.
    - **`infrastructure` (인프라 계층)**:
        - **역할**: 기술적인 세부 사항의 구현.
        - **책임**: **`domain` 계층의 리포지토리 인터페이스에 대한 구체적인 구현체(Adapter)를 제공합니다.** 데이터베이스 연동, 외부 API 호출, 메시징 큐 연동 등을 구현합니다.

3.  **안전한 도메인 모델링 기법**
    - **대수적 데이터 타입 (ADT) 활용**:
        - **Sum Type**: **Kotlin의 `sealed interface`를 사용하여 'A 이거나 B' 같은 배타적 선택 관계를 모델링**하고, `when` 표현식으로 모든 경우를 컴파일 시점에 체크하도록 강제합니다.
        - **Product Type**: **Kotlin의 `data class`를 사용하여 'A 그리고 B' 같은 속성의 조합을 모델링합니다.**
    - **값 객체(Value Object)와 원시 타입 집착 방지**:
        - **`Long`, `String`, `Int`와 같은 원시 타입 대신, `value class`를 사용하여 비즈니스 의미를 갖는 타입을 명시적으로 생성**하고, 생성 시점에 유효성을 검증(`init` 블록 활용)합니다.

4.  **주요 DDD 구성 요소 정의 및 구현 규칙**
    - **애그리게잇(Aggregate)**:
        - **구현 규칙**: 하나의 애그리게잇은 하나의 리포지토리를 통해 관리됩니다. 애그리게잇 루트는 애그리게잇의 유일한 진입점이며, 내부 객체에 대한 직접 접근을 허용하지 않습니다.
    - **엔티티(Entity)**:
        - **구현 규칙**: 고유한 식별자(ID)를 가지며, 비즈니스 로직을 포함하는 풍부한(Rich) 객체로 설계합니다. 단순한 데이터 홀더(Anemic)가 되지 않도록 주의합니다.
    - **값 객체(Value Object)**:
        - **구현 규칙**: `data class` 또는 `value class`를 사용하여 불변으로 만듭니다. `equals()`와 `hashCode()`는 모든 속성을 기반으로 자동 생성된 것을 사용합니다.
    - **리포지토리(Repository)**:
        - **인터페이스 정의 (Domain)**: `domain` 계층에 위치하며, 도메인 모델(애그리게잇, 값 객체)을 반환 타입이나 파라미터 타입으로 사용합니다.
        - **인터페이스 구현 (Infrastructure)**: `infrastructure` 계층에 위치하며, JPA Entity 등 인프라 기술에 종속적인 객체를 내부적으로 사용하되, 외부로 노출할 때는 반드시 도메인 모델로 변환하여 반환합니다.
        - **사용 (Application)**: **`application` 계층에서만** 주입받아 사용합니다.
    - **도메인 서비스(Domain Service)**:
        - **네이밍**: `~Service` 대신 **`~Validator`, `~Policy`, `~Calculator` 등 구체적인 역할을 나타내는 이름**을 사용합니다.
        - **규칙**: 상태를 가지지 않으며(Stateless), **리포지토리를 직접 호출하지 않습니다.** 필요한 모든 도메인 객체는 애플리케이션 서비스로부터 파라미터로 전달받습니다.
    - **도메인 이벤트(Domain Event)**:
        - **구현 규칙**: 도메인 내에서 상태 변경이 완료된 후 발행되는 불변 객체입니다. 이벤트는 과거 시제(`OrderPlaced`, `PaymentCompleted`)로 명명합니다.
    - **바운디드 컨텍스트(Bounded Context)**:
        - **구현 규칙**: 코드 상에서는 주로 Gradle 하위 모듈이나 최상위 패키지로 명확하게 구분하여 컨텍스트 간의 경계를 물리적으로 강제합니다. 컨텍스트 간 통신은 명시적인 API 또는 이벤트를 통해서만 이루어집니다.

# 5 리팩토링 원칙

- **사전 계획 및 승인**: 리팩토링이 필요한 경우, 변경 범위, 목표, 예상 효과 등을 포함한 계획을 설명하고 팀의 허락을 받은 다음 진행합니다.
- **구조 개선 목표**: 리팩토링의 주된 목적은 코드 구조 개선, 가독성 향상, 유지보수성 증대이며, 기존 기능의 변경이나 새로운 기능 추가가 아닙니다.
- **테스트 통과 확인**: 리팩토링 작업 완료 후에는 기존에 작성된 모든 테스트 케이스가 성공적으로 통과하는지 반드시 확인하여 기능적 회귀(Regression)가 없음을 보장합니다.

# 6 디버깅 원칙

- **원인 분석 및 해결책 공유**: 디버깅 시에는 문제의 근본적인 원인과 제안하는 해결책을 명확히 설명하고, 필요한 경우 팀의 동의를 얻은 후 수정 작업을 진행합니다.
- **정확한 동작 보장**: 단순히 에러 메시지를 없애는 것이 아니라, 해당 기능이 의도한 대로 정확하게 동작하도록 수정하는 것을 목표로 합니다.
- **상세 로그 추가**: 문제의 원인이 즉시 파악되지 않거나 재현이 어려운 경우, 분석에 도움이 될 수 있도록 관련 로직에 상세한 로그를 추가하여 추적성을 확보합니다.

# 7 언어 및 문서화

- **영문 사용**:
    - AWS 리소스(예: S3 버킷, EC2 인스턴스 등)의 이름 및 Description은 영어로 작성합니다.
    - Pulumi, CloudFormation 등 IaC 도구에서 설정하는 Description 필드는 영어로 작성합니다.
- **원문 유지**: 기술적인 용어, 라이브러리 이름, 프레임워크 이름 등은 공식 명칭 또는 널리 통용되는 원문을 그대로 사용합니다. (예: `Kubernetes`이지 `쿠버네티스`가 아님)
- **다이어그램**:
    - 간단한 순서도, 상태도 등은 텍스트 기반 다이어그램 도구인 `mermaid`를 사용하여 마크다운 문서 내에 직접 포함시킵니다.
    - 복잡한 아키텍처 다이어그램, 시스템 구성도 등은 별도의 `SVG` (Scalable Vector Graphics) 파일을 생성하고, 이를 문서에 이미지로 포함시킵니다.
- **주석**: 필요한 경우 코드를 이해하는 데 도움이 되는 주석을 작성하되, 코드 자체로 의도가 명확히 드러나도록 작성하는 것을 우선합니다. 유비쿼터스 랭귀지를 사용하여 주석을 작성합니다.

# 8 테스트 심층 원칙

- **테스트 피라미드 준수 및 전략적 테스트 유형 선택**:
    - **단위 테스트 (Unit Tests)**:
        - **핵심 비즈니스 로직 (도메인 계층, 애플리케이션 계층의 순수 로직)**: 이 영역은 **가짜 구현체(Fake Objects)**를 사용하여 테스트하는 것을 우선합니다. 외부 의존성(예: Repository, 외부 서비스 클라이언트)에 대한 인터페이스를 정의하고, 테스트 시에는 이 인터페이스의 가짜 구현체(메모리 기반 또는 단순 로직 수행)를 주입하여 테스트합니다. 이를 통해 Mocking 라이브러리 사용을 최소화하고, 실제 객체 간의 상호작용에 가까운 방식으로 검증하며, 테스트의 가독성과 유지보수성을 높입니다.
        - 상태나 복잡한 로직이 없는 간단한 유틸리티 함수 등은 직접 테스트합니다.
    - **통합 테스트 (Integration Tests)**:
        - **외부 시스템 연동 지점 (인프라 계층)**: 데이터베이스 접근(Repository 구현체), 메시지 큐 연동, 외부 API 클라이언트 등 외부 프레임워크나 시스템과 직접적으로 상호작용하는 컴포넌트는 **실제 기술 스택과 유사한 환경에서 테스트**합니다. 도커테스트컨테이너사용 권장
        - 이를 위해 **Testcontainers**와 같은 도구를 적극 활용하여 테스트 실행 시 격리된 실제 데이터베이스(예: PostgreSQL, MySQL), 메시지 큐(예: Kafka, RabbitMQ) 등의 인스턴스를 동적으로 생성하여 테스트합니다. 이를 통해 실제 운영 환경과의 동작 일관성을 높이고 예기치 않은 문제를 조기에 발견합니다.
        - 여러 컴포넌트 또는 계층 간의 상호작용을 검증할 필요가 있을 때 사용합니다.
    - **종단간 테스트 (E2E Tests)**: 전체 시스템의 주요 사용자 시나리오를 검증하며, 실제 사용자와 동일한 방식으로 시스템과 상호작용합니다. 최소한으로 유지하여 테스트 실행 시간을 관리합니다.
    - 전체적으로 단위 테스트의 비율을 가장 높게 유지하여 빠르고 안정적인 피드백 루프를 구축합니다.
- **커버리지 목표**: 비즈니스 로직의 핵심 부분에 대해서는 최소 90% 이상의 테스트 커버리지를 목표로 하며, 단순 Getter/Setter를 제외한 중요 로직은 100% 커버리지를 지향합니다.
- **Mocking/Stubbing의 제한적 사용**:
    - 핵심 비즈니스 로직 테스트 시 가짜 구현체(Fake) 사용을 우선하며, Mocking 라이브러리는 제어하기 어렵거나 Fake로 대체하기 어려운 극히 제한적인 경우(예: 특정 에러 상황 시뮬레이션, 정적 메소드 호출 등)에만 신중하게 사용합니다.
    - Mock 사용 시에는 행위 검증(Behavior Verification)보다는 상태 검증(State Verification)을 선호하여 테스트가 구현에 덜 종속되도록 합니다.
- **테스트 데이터 관리**: 테스트 데이터는 실제 사용 사례를 반영하되, 민감 정보를 포함하지 않아야 합니다. 각 테스트 케이스는 독립적으로 실행될 수 있도록 테스트 데이터를 격리하여 관리합니다. (예: Test Data Builders)
- **명확한 테스트 명명**: 테스트 메소드(또는 함수)의 이름은 `[테스트_대상_컴포넌트_또는_메소드]_[테스트_시나리오_또는_조건]_[예상_결과]` (예: `OrderService_placeOrder_whenInventoryIsInsufficient_thenThrowsOutOfStockException`)와 같이 테스트의 의도를 명확하게 드러내는 형식을 따릅니다.

# 9 배포 및 운영 원칙

- **자동화된 배포 파이프라인 (CI/CD)**: 코드 커밋부터 빌드, 테스트, 스테이징 배포, 프로덕션 배포까지의 과정을 자동화된 CI/CD 파이프라인을 통해 관리합니다. 깃허브액션 사용
- **점진적 배포 (Progressive Delivery)**: 새로운 기능이나 주요 변경 사항을 배포할 때, 위험을 최소화하기 위해 카나리(Canary) 배포, 블루/그린(Blue/Green) 배포, 기능 플래그(Feature Flag) 등의 점진적 배포 전략을 우선적으로 고려합니다.
- **롤백 계획 (Rollback Plan)**: 모든 배포에는 명확하고 검증된 롤백 계획이 수립되어 있어야 하며, 문제 발생 시 신속하게 이전의 안정적인 버전으로 시스템을 복구할 수 있어야 합니다.
- **모니터링 및 로깅 (Monitoring & Logging)**: 배포된 애플리케이션 및 인프라의 상태(헬스 체크, 성능 지표, 에러율 등)를 지속적으로 모니터링합니다. 문제 발생 시 원인 분석 및 해결에 필요한 충분한 수준의 로그를 수집하고, 로그는 구조화된 형식(예: JSON)으로 관리하여 검색 및 분석 용이성을 높입니다.